package com.coremedia.blueprint.common.util;

import com.coremedia.blueprint.base.settings.SettingsService;
import com.coremedia.blueprint.base.util.StructUtil;
import com.coremedia.blueprint.cae.search.Condition;
import com.coremedia.blueprint.cae.search.SearchConstants;
import com.coremedia.blueprint.cae.search.SearchQueryBean;
import com.coremedia.blueprint.cae.search.Value;
import com.coremedia.blueprint.cae.search.solr.SolrQueryBuilder;
import com.coremedia.blueprint.cae.search.solr.SolrSearchFormatHelper;
import com.coremedia.blueprint.common.contentbeans.CMLocTaxonomy;
import com.coremedia.blueprint.common.contentbeans.CMNavigation;
import com.coremedia.blueprint.common.contentbeans.CMQueryList;
import com.coremedia.blueprint.common.contentbeans.CMTaxonomy;
import com.coremedia.cap.common.IdHelper;
import com.coremedia.cap.content.Content;
import com.coremedia.cap.content.ContentRepository;
import com.coremedia.cap.multisite.Site;
import com.coremedia.cap.multisite.SitesService;
import com.coremedia.cap.struct.Struct;
import com.coremedia.objectserver.beans.ContentBean;
import com.coremedia.objectserver.beans.ContentBeanFactory;
import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.time.DateUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Optional;

import static java.util.Collections.singletonList;

/**
 * Uses the local settings struct generated by the Studio
 * query editor and converts it to a SearchQuery object that
 * is used e.g. for CMQueryList content.
 */
@DefaultAnnotation(NonNull.class)
public class SettingsStructToSearchQueryConverter {
  private static final Logger LOG = LoggerFactory.getLogger(SettingsStructToSearchQueryConverter.class);

  //See RequestAttributeConstants
  private static final String REQUEST_ATTR_NAME_PAGE_MODEL = "cmpage_model";

  private static final String KEY_SUBJECT_TAXONOMY = SearchConstants.FIELDS.SUBJECT_TAXONOMY.toString();
  private static final String KEY_LOCATION_TAXONOMY = SearchConstants.FIELDS.LOCATION_TAXONOMY.toString();
  private static final String KEY_MODIFICATION_DATE = SearchConstants.FIELDS.MODIFICATION_DATE.toString();
  private static final String KEY_DOCUMENT_TYPE = SearchConstants.FIELDS.DOCUMENTTYPE.toString();

  private static final String KEY_CONTEXT_TAXONOMIES = "contextTaxonomies";

  private static final String KEY_DOCUMENTS = "documents";
  private static final String KEY_LIMIT = "limit";
  private static final String KEY_ORDER = "order";

  private static final String KEY_FQ = "fq";

  private final CMQueryList queryList;
  private final SitesService sitesService;
  private final SettingsService settingsService;
  private final ContentBeanFactory contentBeanFactory;
  private final ContentRepository contentRepository;

  public SettingsStructToSearchQueryConverter(CMQueryList queryList,
                                              SitesService sitesService,
                                              SettingsService settingsService,
                                              ContentRepository contentRepository,
                                              ContentBeanFactory contentBeanFactory) {
    this.queryList = queryList;
    this.sitesService = sitesService;
    this.settingsService = settingsService;
    this.contentBeanFactory = contentBeanFactory;
    this.contentRepository = contentRepository;
  }

  /**
   * Reads the solr search settings from the local settings properties.
   * The struct xml has been generated by the dynamic query editor in the Studio.
   *
   * @return The SearchQueryBean.
   */
  public SearchQueryBean convert() {
    SearchQueryBean searchQuery = new SearchQueryBean();
    searchQuery.setQuery(SolrQueryBuilder.ANY_FIELD_ANY_VALUE);

    // prevent cross site searches
    sitesService.getContentSiteAspect(queryList.getContent())
      .findSite()
      .map(Site::getSiteRootDocument)
      .ifPresent(root -> searchQuery.setContext(String.valueOf(IdHelper.parseContentId(root.getId()))));

    applyLimit(searchQuery);
    applyOrder(searchQuery);

    Struct fqStruct = settingsService.setting(KEY_FQ, Struct.class, queryList.getContent());
    if (fqStruct != null) {
      applyDocumentType(fqStruct, searchQuery);
      applyContexts(fqStruct, searchQuery);
      applyKeywords(fqStruct, KEY_SUBJECT_TAXONOMY, SearchConstants.FIELDS.SUBJECT_TAXONOMY, searchQuery);
      applyKeywords(fqStruct, KEY_LOCATION_TAXONOMY, SearchConstants.FIELDS.LOCATION_TAXONOMY, searchQuery);
      applyContextKeywords(fqStruct, KEY_CONTEXT_TAXONOMIES, searchQuery);
      applyModificationDate(fqStruct, searchQuery);
    }

    return searchQuery;
  }

  /**
   * Applies the order by param to the query if set.
   * @param searchQuery
   */
  private void applyOrder(SearchQueryBean searchQuery) {
    String orderBy = settingsService.setting(KEY_ORDER, String.class, queryList.getContent());
    if (orderBy!=null && orderBy.contains(" ")) {
      String field = orderBy.split(" ")[0];
      for (int i = 0; i < SearchConstants.FIELDS.values().length; i++) {
        if (SearchConstants.FIELDS.values()[i].toString().equalsIgnoreCase(field)) {
          List<String> sortFields = new ArrayList<>();
          sortFields.add(orderBy);
          searchQuery.setSortFields(sortFields);
        }
      }
    }
  }

  /**
   * Applies the number of items.
   * @param searchQuery
   */
  private void applyLimit(SearchQueryBean searchQuery) {
    Integer limit = settingsService.setting(KEY_LIMIT, Integer.class, queryList.getContent());
    if (limit!=null && limit>0) {
      searchQuery.setLimit(limit);
    }
  }

  /**
   * Applies the publication date to the query.
   * Be aware that the publication date can be entered without formatting
   * using the expert mode of the Studio!
   */
  private void applyModificationDate(Struct fqStruct, SearchQueryBean searchQuery) {
    String dateString = StructUtil.getString(fqStruct, KEY_MODIFICATION_DATE);
    if (!StringUtils.isEmpty(dateString)) {
      if (dateString.contains(":")) {
        dateString = dateString.split(":")[1];
      }

      if (dateString.length() > 0) {
        Calendar calculatedDate = calcDate(dateString);
        String formattedString = SolrSearchFormatHelper.calendarToString(calculatedDate);
        searchQuery.addFilter(Condition.greaterThan(SearchConstants.FIELDS.MODIFICATION_DATE, Value.exactly(formattedString)));
      }
    }
  }

  /**
   * Takes the documents from the query (channel documents)
   * add them as navigation criteria to the query.
   */
  private void applyContexts(Struct fqStruct, SearchQueryBean searchQuery) {
    List<Content> docs = StructUtil.getLinks(fqStruct, KEY_DOCUMENTS);
    if (!docs.isEmpty()) {
      List<CMNavigation> navigations = contentBeanFactory.createBeansFor(docs, CMNavigation.class);
      List<String> convertedNavigation = ContentBeanSolrSearchFormatHelper.cmNavigationsToId(navigations);
      searchQuery.addFilter(Condition.is(
              SearchConstants.FIELDS.NAVIGATION_PATHS, Value.anyOf(convertedNavigation)));
    }
  }


  /**
   * Parses the documents types, retrieves the concrete instances from
   * the repository and adds them to the query list.
   */
  private void applyDocumentType(Struct fqStruct, SearchQueryBean searchQuery) {
    String docTypes = StructUtil.getString(fqStruct, KEY_DOCUMENT_TYPE);
    if (!StringUtils.isEmpty(docTypes)) {
      final Condition documentTypeFilter = SearchQueryUtil.createDocumentTypeFilter(docTypes, contentRepository);
      searchQuery.addFilter(documentTypeFilter);
    }
  }

  /**
   * Parsing keywords and applying them to the query.
   *  @param fqId  the struct field used to load the selected keywords
   * @param field the solr field used to store the information
   * @param searchQuery
   */
  private void applyKeywords(Struct fqStruct, String fqId, SearchConstants.FIELDS field, SearchQueryBean searchQuery) {
    List<Content> docs = StructUtil.getLinks(fqStruct, fqId);
    if (!docs.isEmpty()) {
      List<CMTaxonomy> taxonomies = contentBeanFactory.createBeansFor(docs, CMTaxonomy.class);
      List<String> taxonomyIds = ContentBeanSolrSearchFormatHelper.cmObjectsToIds(taxonomies);
      searchQuery.addFilter(Condition.is(field, Value.anyOf(taxonomyIds)));
    }
  }


  /**
   * Parsing related keywords and applying them to the query.
   *
   * @param fqId  the struct field used to load the selected keywords
   * @param searchQuery
   */
  private void applyContextKeywords(Struct fqStruct, String fqId, SearchQueryBean searchQuery) {
    boolean useContextTaxonomies = StructUtil.getBoolean(fqStruct, fqId);
    if (useContextTaxonomies) {
      Content taxonomy = getCurrentTaxonomy().orElse(null);
      if (taxonomy!=null) {
        LOG.debug("Found taxonomy {} in the request, use this for the CMQueryList as context", taxonomy);
        String id = String.valueOf(IdHelper.parseContentId(taxonomy.getId()));
        if(taxonomy.getType().isSubtypeOf(CMLocTaxonomy.NAME)) {
          searchQuery.addFilter(Condition.is(SearchConstants.FIELDS.LOCATION_TAXONOMY, Value.anyOf(singletonList(id))));
        } else  {
          searchQuery.addFilter(Condition.is(SearchConstants.FIELDS.SUBJECT_TAXONOMY, Value.anyOf(singletonList(id))));
        }
      }
    }
  }

  private Optional<Content> getCurrentTaxonomy() {
    Optional<ContentBean> taxonomyBean = ContextAttributes
      .findRequestAttribute(REQUEST_ATTR_NAME_PAGE_MODEL, ContentBean.class);
    Optional<Content> content = taxonomyBean
      .map(ContentBean::getContent);
    if (!content.isPresent()) {
      content = ContextAttributes.findSessionAttribute(REQUEST_ATTR_NAME_PAGE_MODEL, String.class)
        .map(id -> contentRepository.getContent(id));
    }
    return content
      .filter(c -> c.getType().isSubtypeOf(CMTaxonomy.NAME));
  }

  /**
   * Checks the settings done by the modification date query editor.
   * Creates and manipulates a date for it.
   *
   * @param dateString The raw format serialized in the struct.
   * @return The date that should be used as (mod) date for the query.
   */
  private Calendar calcDate(String dateString) {
    Calendar cal = new GregorianCalendar();
    String replacedDateString = dateString.replaceAll("\\[", "").replaceAll("\\]", "");
    if (replacedDateString.contains("TODAY")) {
      //because today started at midnight!
      cal.set(Calendar.HOUR_OF_DAY, 0);
      cal.set(Calendar.MINUTE, 0);
      cal.set(Calendar.SECOND, 0);
      cal.set(Calendar.MILLISECOND, 0);
    } else
    if (replacedDateString.contains("DAYS TO NOW")) {
      int days = Integer.parseInt(replacedDateString.split(" ")[0]);
      Date formattedDate = DateUtils.addDays(cal.getTime(), -days);
      cal.setTime(formattedDate);
    }
    return cal;
  }
}
